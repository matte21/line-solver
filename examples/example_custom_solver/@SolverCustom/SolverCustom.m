classdef SolverCustom < NetworkSolver
    % Example of custom solver
    %
    % Copyright (c) 2012-2022, Imperial College London
    % All rights reserved.

    methods
        function self = SolverCustom(model,varargin)
            % SELF = SolverCustom(MODEL,VARARGIN)

            self@NetworkSolver(model, mfilename);
            self.setOptions(Solver.parseOptions(varargin, self.defaultOptions));
        end

        runtime = run(self)

        function sn = getStruct(self)
            % QN = GETSTRUCT()

            % Get data structure summarizing the model
            sn = self.model.getStruct(false);
        end

        [runtime, analyzer] = runAnalyzer(self, options);
    end

    methods (Static)
        function featSupported = getFeatureSet()
            % FEATSUPPORTED = GETFEATURESET()

            featSupported = SolverFeatureSet;
            featSupported.setTrue({'Sink',...
                'Source',...
                'Router',...
                'ClassSwitch',...
                'DelayStation',...
                'Queue',...
                'Fork',...
                'Join',...
                'Forker',...
                'Joiner',...
                'Logger',...
                'Coxian',...
                'Cox2',...
                'APH',...
                'Erlang',...
                'Exponential',...
                'HyperExp',...
                'Det',...
                'Gamma',...
                'Lognormal',...
                'MAP',...
                'MMPP2',...
                'Normal',...
                'PH',...
                'Pareto',...
                'Weibull',...
                'Replayer',...
                'Uniform',...
                'StatelessClassSwitcher',...
                'InfiniteServer',...
                'SharedServer',...
                'Buffer',...
                'Dispatcher',...
                'Server',...
                'JobSink',...
                'RandomSource',...
                'ServiceTunnel',...
                'LogTunnel',...
                'Buffer', ...
                'Linkage',...
                'Enabling', ...
                'Timing', ...
                'Firing', ...
                'Storage', ...
                'Place', ...
                'Transition', ...
                'SchedStrategy_INF',...
                'SchedStrategy_PS',...
                'SchedStrategy_DPS',...
                'SchedStrategy_FCFS',...
                'SchedStrategy_GPS',...
                'SchedStrategy_SIRO',...
                'SchedStrategy_HOL',...
                'SchedStrategy_LCFS',...
                'SchedStrategy_LCFSPR',...
                'SchedStrategy_SEPT',...
                'SchedStrategy_LEPT',...
                'SchedStrategy_SJF',...
                'SchedStrategy_LJF',...
                'RoutingStrategy_PROB',...
                'RoutingStrategy_RAND',...
                'RoutingStrategy_RROBIN',...
                'RoutingStrategy_WRROBIN',...
                'RoutingStrategy_KCHOICES',...
                'SchedStrategy_EXT',...
                'ClosedClass',...
                'OpenClass'});
        end

        function [bool, featSupported] = supports(model)
            % [BOOL, FEATSUPPORTED] = SUPPORTS(MODEL)

            featUsed = model.getUsedLangFeatures();
            featSupported = SolverCustom.getFeatureSet();
            bool = SolverFeatureSet.supports(featSupported, featUsed);
        end
    end

    methods (Static)
        function options = defaultOptions()
            % OPTIONS = DEFAULTOPTIONS()

            options = Solver.defaultOptions();
            options.timespan = [Inf,Inf];
        end
    end
end
